<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on packnback</title>
    <link>https://packnback.github.io/blog/</link>
    <description>Recent content in Blogs on packnback</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 Sep 2018 11:26:59 +1200</lastBuildDate>
    
	<atom:link href="https://packnback.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Programming languages</title>
      <link>https://packnback.github.io/blog/programming_languages/</link>
      <pubDate>Thu, 20 Sep 2018 11:26:59 +1200</pubDate>
      
      <guid>https://packnback.github.io/blog/programming_languages/</guid>
      <description>Choosing a programming language for a project is a compromise over what you what you need, what you have, what you know and what you like. This post is just my thought process when selecting the implementation for packnback.
What we need  High performance, we will hopefully be dealing with large volumes of data. High security, the whole purpose is to protect data from attackers. Stability, software needs to be usable well into the future.</description>
    </item>
    
    <item>
      <title>Deduplication and encryption</title>
      <link>https://packnback.github.io/blog/dedup_and_encryption/</link>
      <pubDate>Sat, 15 Sep 2018 11:26:59 +1200</pubDate>
      
      <guid>https://packnback.github.io/blog/dedup_and_encryption/</guid>
      <description>One problem we have is deduplicating encrypted data so that the server is not able to guess what data is being stored. Here I will try to present a few schemes that might be acceptable and disuss some that are not.
Git model If you are familiar with git, it takes the approach of hashing files, then storing them in a key value database where the hash is the key.</description>
    </item>
    
    <item>
      <title>Asymmetric cryptography</title>
      <link>https://packnback.github.io/blog/asymmetric_encryption/</link>
      <pubDate>Fri, 14 Sep 2018 09:25:10 +1200</pubDate>
      
      <guid>https://packnback.github.io/blog/asymmetric_encryption/</guid>
      <description>Rather than spend time explaining (poorly) how public/asymmetric key cryptography works, I&amp;rsquo;ll just summarize the parts we will be using.
 A key is two parts, public and private. A message can be encrypted and addressed to a key. The public part of a key can be freely distributed. An encrypted message can only be decrypted by the corresponding private key part. A message can be &amp;lsquo;signed&amp;rsquo; by someone with the private key part.</description>
    </item>
    
    <item>
      <title>Work begins</title>
      <link>https://packnback.github.io/blog/work_begins/</link>
      <pubDate>Fri, 10 Aug 2018 09:25:10 +1200</pubDate>
      
      <guid>https://packnback.github.io/blog/work_begins/</guid>
      <description>This is the beginning of a project to design and implement a new backup tool called packnback.
It makes sense to explain why we should bother in the first place, and what interesting features a new tool can bring to the table.
Ideal features Let&amp;rsquo;s list features that are important in a backup tool and them to existing tools so we get a good idea of the current backup tool choices you might have as an administrator trying to bullet proof a your server environment.</description>
    </item>
    
  </channel>
</rss>